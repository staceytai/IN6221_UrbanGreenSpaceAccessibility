<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard 4</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        .header-container {
            flex-shrink: 0;
        }

        .content-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .container {
            width: 50%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }

        #chart1 {
            flex: 1;
            background-color: #b3d9ff;
            margin: 0;
        }

        .right-container {
            width: 50%;
            display: flex;
            flex-direction: column;
        }

        .right-top {
            height: 50%;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            overflow: hidden;
            padding: 10px;
            box-sizing: border-box;
        }

        .right-bottom {
            height: 50%;
            background-color: #f8f8f8;
            border: 1px solid #ccc;
            overflow: hidden;
            padding: 10px;
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <div class="header-container">
        <h1>Urban Green Space Accessibility</h1>
        <nav>
            <a href="dashboard1.html">Dashboard 1</a>
            <a href="dashboard2.html">Dashboard 2</a>
            <a href="dashboard3.html">Dashboard 3</a>
            <a href="dashboard4.html" class="active">Dashboard 4</a>
            <a href="dashboard5.html">Dashboard 5</a>
        </nav>
    </div>

    <div class="content-wrapper">
        <div class="container">
            <div id="chart1" class="chart" style="position: relative;">
                <div id="map-title"
                    style="position: absolute; top: 10px; left: 10px; z-index: 100; font-size: 24px; font-weight: bold; color: #333; padding: 10px; border-radius: 5px;">
                    Open Space Distribution in Singapore
                </div>
                <div id="map-legend"
                    style="position: absolute; top: 70px; left: 10px; z-index: 100; background: white; padding: 15px; border: 1px solid #333; border-radius: 5px; opacity: 0.95;">
                    <div style="font-size: 14px; font-weight: bold; margin-bottom: 10px;">Singapore Land Use Map</div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div style="width: 20px; height: 2px; background: #999; margin-right: 10px;"></div>
                        <span style="font-size: 12px;">Planning Area Boundaries</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div
                            style="width: 20px; height: 15px; background: #2ecc71; border: 1px solid #27ae60; margin-right: 10px;">
                        </div>
                        <span style="font-size: 12px;" id="openspace-count">Open Spaces</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div
                            style="width: 20px; height: 15px; background: #16a085; border: 1px solid #0e6655; margin-right: 10px;">
                        </div>
                        <span style="font-size: 12px;" id="reservesite-count">Reserve Sites</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div
                            style="width: 20px; height: 15px; background: #9b59b6; border: 1px solid #7d3c98; margin-right: 10px;">
                        </div>
                        <span style="font-size: 12px;" id="parkarea-count">Park Areas</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div
                            style="width: 20px; height: 15px; background: #f8d7da; border: 1px solid #e8b4b8; margin-right: 10px;">
                        </div>
                        <span style="font-size: 12px;" id="residential-count">Residential</span>
                    </div>
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <div
                            style="width: 12px; height: 12px; background: #c0392b; border: 2px solid #922b21; border-radius: 50%; margin-right: 10px; margin-left: 4px;">
                        </div>
                        <span style="font-size: 12px;" id="parks-count">Parks</span>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <div style="width: 20px; height: 3px; background: #e67e22; margin-right: 10px;"></div>
                        <span style="font-size: 12px;" id="tracks-count">NParks Tracks</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="right-container">
            <div class="right-top" id="histogram-container">
                <h3 style="margin: 0 0 10px 0; font-size: 16px;">Park Accessibility Distance</h3>
                <svg id="histogram"></svg>
            </div>
            <div class="right-bottom" id="interactive-map-container" style="position: relative;">
                <h3 style="margin: 0 0 5px 0; font-size: 16px;">Click-to-Analyze: Find Nearest Park</h3>
                <p style="margin: 0 0 5px 0; font-size: 11px; color: #666;">Click anywhere on the map to find the
                    nearest park</p>
                <div id="distance-info"
                    style="position: absolute; top: 40px; right: 10px; font-size: 11px; color: #333; background: #f0f0f0; padding: 8px; border: 1px solid #ccc; border-radius: 4px; max-width: 200px; z-index: 100;">
                    <div
                        style="font-weight: bold; font-size: 12px; margin-bottom: 5px; border-bottom: 1px solid #ddd; padding-bottom: 3px;">
                        üìçDistance to Nearest Park</div>
                    <div id="distance-content">Click anywhere on the map to find the nearest park</div>
                </div>
                <svg id="interactive-map"></svg>
            </div>
        </div>
    </div>

    <script>
        // Set up dimensions
        const width = 1200;
        const height = 800;

        /**
         * Create the map
         * */
        // Create SVG
        const svg = d3.select("#chart1")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${width} ${height}`)
            .attr("preserveAspectRatio", "xMidYMid meet");

        // Create a group for zoom
        const g = svg.append("g");

        // Add loading text
        const loadingText = svg.append("text")
            .attr("x", width / 2)
            .attr("y", height / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "20px")
            .text("Loading map data...");

        // Load all GeoJSON files
        Promise.all([
            d3.json("../src/MasterPlan2019PlanningAreaBoundaryNoSea.geojson"),
            d3.json("../src/MasterPlan2019LandUselayer.geojson"),
            d3.json("../src/Parks.geojson"),
            d3.json("../src/NParksTracks.geojson")
        ]).then(function ([boundaryData, landUseData, parksData, tracksData]) {
            // Remove loading text
            loadingText.remove();

            /**
             * Helper function to extract LU_DESC from HTML Description
             * @param {Object} feature - The feature to extract the LU_DESC from
             * @returns {string} The LU_DESC of the feature
             * */
            function getLandUseType(feature) {
                const desc = feature.properties.Description;
                if (!desc) return null;
                const match = desc.match(/<th>LU_DESC<\/th>\s*<td>([^<]+)<\/td>/);
                return match ? match[1] : null;
            }

            /**
             * Helper function to extract planning area name
             * @param {Object} feature - The feature to extract the planning area name from
             * @returns {string} The planning area name of the feature
             * */
            function getPlanningAreaName(feature) {
                const desc = feature.properties.Description;
                if (!desc) return null;
                const match = desc.match(/<th>PLN_AREA_N<\/th>\s*<td>([^<]+)<\/td>/);
                return match ? match[1] : null;
            }

            /**
             * Helper function to extract region name
             * @param {Object} feature - The feature to extract the region name from
             * @returns {string} The region name of the feature
             * */
            function getRegionName(feature) {
                const desc = feature.properties.Description;
                if (!desc) return null;
                const match = desc.match(/<th>REGION_N<\/th>\s*<td>([^<]+)<\/td>/);
                return match ? match[1] : null;
            }

            // Filter data by land use types
            const openSpaceData = {
                ...landUseData,
                features: landUseData.features.filter(d => getLandUseType(d) === "OPEN SPACE")
            };

            const reserveSiteData = {
                ...landUseData,
                features: landUseData.features.filter(d => getLandUseType(d) === "RESERVE SITE")
            };

            // Park Areas group
            const parkAreaTypes = ["PARK", "BUSINESS PARK", "BUSINESS PARK - WHITE"];
            const parkAreaData = {
                ...landUseData,
                features: landUseData.features.filter(d => parkAreaTypes.includes(getLandUseType(d)))
            };

            // Residential group
            const residentialTypes = ["RESIDENTIAL", "RESIDENTIAL WITH COMMERCIAL AT 1ST STOREY", "COMMERCIAL & RESIDENTIAL", "RESIDENTIAL / INSTITUTION"];
            const residentialData = {
                ...landUseData,
                features: landUseData.features.filter(d => residentialTypes.includes(getLandUseType(d)))
            };

            console.log(`Displaying ${openSpaceData.features.length} Open Space areas`);
            console.log(`Displaying ${reserveSiteData.features.length} Reserve Sites`);
            console.log(`Displaying ${parkAreaData.features.length} Park Areas`);
            console.log(`Displaying ${residentialData.features.length} Residential areas`);

            // Extract all unique land use types
            const allLandUseTypes = new Set();
            const landUseTypeCounts = {};

            landUseData.features.forEach(feature => {
                const landUseType = getLandUseType(feature);
                if (landUseType) {
                    allLandUseTypes.add(landUseType);
                    landUseTypeCounts[landUseType] = (landUseTypeCounts[landUseType] || 0) + 1;
                }
            });

            console.log("\n=== ALL LAND USE TYPES IN FILE ===");
            console.log(`Total unique types: ${allLandUseTypes.size}`);
            console.log("\nLand Use Types with counts:");

            // Sort by count (descending)
            const sortedTypes = Object.entries(landUseTypeCounts)
                .sort((a, b) => b[1] - a[1]);

            sortedTypes.forEach(([type, count]) => {
                console.log(`  ${type}: ${count} areas`);
            });
            console.log("===================================\n");

            // Create a projection for Singapore based on boundary data
            const projection = d3.geoMercator()
                .fitSize([width, height], boundaryData);

            // Create a path generator
            const path = d3.geoPath()
                .projection(projection);

            // Draw the planning area boundaries first (base layer)
            g.selectAll("path.boundary")
                .data(boundaryData.features)
                .enter()
                .append("path")
                .attr("class", "boundary")
                .attr("d", path)
                .attr("fill", "#fef5e7")
                .attr("stroke", "#999")
                .attr("stroke-width", 1)
                .attr("opacity", 1)
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .attr("fill", "#ffe4b3")  // Slightly darker yellow on hover
                        .attr("stroke", "#666")
                        .attr("stroke-width", 2);

                    // Extract planning area and region
                    const planningArea = getPlanningAreaName(d);
                    const region = getRegionName(d);

                    // Show tooltip
                    tooltip.style("display", "block")
                        .html(`<strong>${planningArea}</strong><br/>
                               Region: ${region}`);
                })
                .on("mousemove", function (event) {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    d3.select(this)
                        .attr("fill", "#fef5e7")
                        .attr("stroke", "#999")
                        .attr("stroke-width", 1);

                    tooltip.style("display", "none");
                });

            // Draw the map - only Open Space areas in green
            g.selectAll("path.openspace")
                .data(openSpaceData.features)
                .enter()
                .append("path")
                .attr("class", "openspace")
                .attr("d", path)
                .attr("fill", "#2ecc71")  // Green color for open spaces
                .attr("stroke", "#27ae60")  // Darker green for borders
                .attr("stroke-width", 0.5)
                .attr("opacity", 0.8)
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .attr("opacity", 1)
                        .attr("stroke-width", 2)
                        .attr("stroke", "#1e8449");

                    // Extract properties from Description
                    const landUse = getLandUseType(d);
                    const desc = d.properties.Description;
                    const gprMatch = desc ? desc.match(/<th>GPR<\/th>\s*<td>([^<]+)<\/td>/) : null;
                    const gpr = gprMatch ? gprMatch[1] : 'N/A';

                    // Show tooltip
                    tooltip.style("display", "block")
                        .html(`<strong>${landUse}</strong><br/>
                               GPR: ${gpr}<br/>
                               Name: ${d.properties.Name || 'N/A'}`);
                })
                .on("mousemove", function (event) {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    d3.select(this)
                        .attr("opacity", 0.8)
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#27ae60");

                    tooltip.style("display", "none");
                });

            // Draw Reserve Sites
            g.selectAll("path.reservesite")
                .data(reserveSiteData.features)
                .enter()
                .append("path")
                .attr("class", "reservesite")
                .attr("d", path)
                .attr("fill", "#16a085")  // Teal-green color for reserve sites
                .attr("stroke", "#0e6655")  // Darker teal for borders
                .attr("stroke-width", 0.5)
                .attr("opacity", 0.8)
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .attr("opacity", 1)
                        .attr("stroke-width", 2)
                        .attr("stroke", "#0a4f3f");

                    const landUse = getLandUseType(d);
                    const desc = d.properties.Description;
                    const gprMatch = desc ? desc.match(/<th>GPR<\/th>\s*<td>([^<]+)<\/td>/) : null;
                    const gpr = gprMatch ? gprMatch[1] : 'N/A';

                    tooltip.style("display", "block")
                        .html(`<strong>${landUse}</strong><br/>
                               GPR: ${gpr}<br/>
                               Name: ${d.properties.Name || 'N/A'}`);
                })
                .on("mousemove", function (event) {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    d3.select(this)
                        .attr("opacity", 0.8)
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#0e6655");

                    tooltip.style("display", "none");
                });

            // Draw Park Areas
            g.selectAll("path.parkarea")
                .data(parkAreaData.features)
                .enter()
                .append("path")
                .attr("class", "parkarea")
                .attr("d", path)
                .attr("fill", "#9b59b6")  // Purple color for park areas
                .attr("stroke", "#7d3c98")  // Darker purple for borders
                .attr("stroke-width", 0.5)
                .attr("opacity", 0.8)
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .attr("opacity", 1)
                        .attr("stroke-width", 2)
                        .attr("stroke", "#5b2c6f");

                    const landUse = getLandUseType(d);
                    const desc = d.properties.Description;
                    const gprMatch = desc ? desc.match(/<th>GPR<\/th>\s*<td>([^<]+)<\/td>/) : null;
                    const gpr = gprMatch ? gprMatch[1] : 'N/A';

                    tooltip.style("display", "block")
                        .html(`<strong>Park Areas</strong><br/>
                               Type: ${landUse}<br/>
                               GPR: ${gpr}`);
                })
                .on("mousemove", function (event) {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    d3.select(this)
                        .attr("opacity", 0.8)
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#7d3c98");

                    tooltip.style("display", "none");
                });

            // Draw Residential areas
            g.selectAll("path.residential")
                .data(residentialData.features)
                .enter()
                .append("path")
                .attr("class", "residential")
                .attr("d", path)
                .attr("fill", "#f8d7da")  // Light pink color for residential
                .attr("stroke", "#e8b4b8")  // Pink border
                .attr("stroke-width", 0.3)
                .attr("opacity", 0.7)
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .attr("opacity", 1)
                        .attr("stroke-width", 1.5)
                        .attr("stroke", "#d4949a");

                    const landUse = getLandUseType(d);
                    const desc = d.properties.Description;
                    const gprMatch = desc ? desc.match(/<th>GPR<\/th>\s*<td>([^<]+)<\/td>/) : null;
                    const gpr = gprMatch ? gprMatch[1] : 'N/A';

                    tooltip.style("display", "block")
                        .html(`<strong>Residential</strong><br/>
                               Type: ${landUse}<br/>
                               GPR: ${gpr}`);
                })
                .on("mousemove", function (event) {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    d3.select(this)
                        .attr("opacity", 0.7)
                        .attr("stroke-width", 0.3)
                        .attr("stroke", "#e8b4b8");

                    tooltip.style("display", "none");
                });

            // Draw parks as markers (circles)
            g.selectAll("circle.park")
                .data(parksData.features)
                .enter()
                .append("circle")
                .attr("class", "park")
                .attr("cx", d => projection(d.geometry.coordinates)[0])
                .attr("cy", d => projection(d.geometry.coordinates)[1])
                .attr("r", 4)
                .attr("fill", "#c0392b")  // Red color for parks
                .attr("stroke", "#922b21")  // Darker red border
                .attr("stroke-width", 1)
                .attr("opacity", 0.8)
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .attr("r", 6)
                        .attr("opacity", 1);

                    // Show tooltip
                    tooltip.style("display", "block")
                        .html(`<strong>${d.properties.NAME}</strong><br/>
                               Type: Park<br/>
                               ID: ${d.properties.OBJECTID}`);
                })
                .on("mousemove", function (event) {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    d3.select(this)
                        .attr("r", 4)
                        .attr("opacity", 0.8);

                    tooltip.style("display", "none");
                });

            console.log(`Displaying ${parksData.features.length} parks`);

            // Draw NParksTracks as paths
            g.selectAll("path.track")
                .data(tracksData.features)
                .enter()
                .append("path")
                .attr("class", "track")
                .attr("d", path)
                .attr("fill", "none")
                .attr("stroke", "#e67e22")  // Orange color for tracks
                .attr("stroke-width", 2)
                .attr("opacity", 0.7)
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .attr("stroke-width", 4)
                        .attr("opacity", 1);

                    // Show tooltip
                    tooltip.style("display", "block")
                        .html(`<strong>NParks Track/Path</strong><br/>
                               Track ID: ${d.id || 'N/A'}`);
                })
                .on("mousemove", function (event) {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    d3.select(this)
                        .attr("stroke-width", 2)
                        .attr("opacity", 0.7);

                    tooltip.style("display", "none");
                });

            console.log(`Displaying ${tracksData.features.length} tracks`);

            // Add zoom functionality
            const zoom = d3.zoom()
                .scaleExtent([1, 8])
                .on("zoom", function (event) {
                    g.attr("transform", event.transform);
                });

            svg.call(zoom);

            // Update the HTML legend with the counts
            document.getElementById("openspace-count").textContent = `Open Spaces (${openSpaceData.features.length} areas)`;
            document.getElementById("reservesite-count").textContent = `Reserve Sites (${reserveSiteData.features.length} sites)`;
            document.getElementById("parkarea-count").textContent = `Park Areas (${parkAreaData.features.length} areas)`;
            document.getElementById("residential-count").textContent = `Residential (${residentialData.features.length} areas)`;
            document.getElementById("parks-count").textContent = `Parks (${parksData.features.length} locations)`;
            document.getElementById("tracks-count").textContent = `NParks Tracks (${tracksData.features.length} paths)`;

            // Calculate Park Accessibility - distance from residential areas to nearest park
            const distances = [];

            residentialData.features.forEach(resFeature => {
                // Calculate centroid of residential polygon
                const coords = resFeature.geometry.coordinates[0];
                let sumLon = 0, sumLat = 0, count = 0;

                coords.forEach(coord => {
                    sumLon += coord[0];
                    sumLat += coord[1];
                    count++;
                });

                const centroidLon = sumLon / count;
                const centroidLat = sumLat / count;

                // Find nearest park
                let minDistance = Infinity;

                parksData.features.forEach(park => {
                    const parkLon = park.geometry.coordinates[0];
                    const parkLat = park.geometry.coordinates[1];

                    // Calculate Haversine distance in meters
                    const R = 6371000; // Earth's radius in meters
                    const dLat = (parkLat - centroidLat) * Math.PI / 180;
                    const dLon = (parkLon - centroidLon) * Math.PI / 180;
                    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(centroidLat * Math.PI / 180) * Math.cos(parkLat * Math.PI / 180) *
                        Math.sin(dLon / 2) * Math.sin(dLon / 2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    const distance = R * c;

                    if (distance < minDistance) {
                        minDistance = distance;
                    }
                });

                if (minDistance !== Infinity) {
                    distances.push(minDistance);
                }
            });

            console.log(`Calculated distances for ${distances.length} residential areas`);

            // Create histogram
            createHistogram(distances);

            // Create interactive map
            createInteractiveMap(boundaryData, parksData);

        }).catch(function (error) {
            console.error("Error loading GeoJSON:", error);
            loadingText.text("Error loading map data. Please check the file path.");
        });

        /**
         * Function to create the histogram
         * @param {Array} distances - The distances from each residential area to the nearest park
         * */
        function createHistogram(distances) {
            const container = document.getElementById("histogram-container");
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const histSvg = d3.select("#histogram");
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const histWidth = containerWidth - margin.left - margin.right - 20; // 20 for padding (10px * 2)
            const histHeight = containerHeight - margin.top - margin.bottom - 45; // 45 for title (16px + 10px + 10px padding + margin)

            // Clear any existing content
            histSvg.selectAll("*").remove();

            // Set SVG dimensions
            histSvg.attr("width", containerWidth - 20)
                .attr("height", containerHeight - 35);

            const g = histSvg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create bins (distance ranges in meters)
            const maxDist = d3.max(distances);
            const bins = d3.bin()
                .domain([0, maxDist])
                .thresholds(20)(distances);

            // Create scales
            const x = d3.scaleLinear()
                .domain([0, maxDist])
                .range([0, histWidth]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([histHeight, 0]);

            // Add bars
            g.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", d => x(d.x0) + 1)
                .attr("y", d => y(d.length))
                .attr("width", d => Math.max(0, x(d.x1) - x(d.x0) - 2))
                .attr("height", d => histHeight - y(d.length))
                .attr("fill", "#2ecc71")
                .attr("stroke", "#27ae60")
                .attr("stroke-width", 1)
                .attr("opacity", 0.8)
                .on("mouseover", function (event, d) {
                    d3.select(this).attr("opacity", 1);
                    const avgDist = (d.x0 + d.x1) / 2;
                    histTooltip.style("display", "block")
                        .html(`Distance: ${Math.round(avgDist)}m - ${Math.round(d.x1)}m<br/>
                               Residential Areas: ${d.length}`);
                })
                .on("mousemove", function (event) {
                    histTooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    d3.select(this).attr("opacity", 0.8);
                    histTooltip.style("display", "none");
                });

            // Add X axis
            g.append("g")
                .attr("transform", `translate(0,${histHeight})`)
                .call(d3.axisBottom(x).ticks(5))
                .append("text")
                .attr("x", histWidth / 2)
                .attr("y", 40)
                .attr("fill", "black")
                .style("font-size", "12px")
                .style("text-anchor", "middle")
                .text("Distance to Nearest Park (meters)");

            // Add Y axis
            g.append("g")
                .call(d3.axisLeft(y))
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -histHeight / 2)
                .attr("y", -45)
                .attr("fill", "black")
                .style("font-size", "12px")
                .style("text-anchor", "middle")
                .text("Number of Residential Areas");

            // Add statistics text
            const avgDistance = d3.mean(distances);
            const medianDistance = d3.median(distances);

            g.append("text")
                .attr("x", histWidth)
                .attr("y", -5)
                .attr("text-anchor", "end")
                .style("font-size", "11px")
                .style("fill", "#666")
                .text(`Avg: ${Math.round(avgDistance)}m | Median: ${Math.round(medianDistance)}m`);
        }

        // Create histogram tooltip
        const histTooltip = d3.select("body")
            .append("div")
            .style("position", "absolute")
            .style("display", "none")
            .style("background", "rgba(0, 0, 0, 0.8)")
            .style("color", "white")
            .style("padding", "8px")
            .style("border-radius", "4px")
            .style("font-size", "12px")
            .style("pointer-events", "none")
            .style("z-index", "1000");

        /**
         * Function to create interactive map
         * @param {Object} boundaryData - The boundary data for Singapore
         * @param {Object} parksData - The parks data for Singapore
         * */
        function createInteractiveMap(boundaryData, parksData) {
            const container = document.getElementById("interactive-map-container");
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const mapSvg = d3.select("#interactive-map");
            const mapWidth = containerWidth - 20;
            const mapHeight = containerHeight - 45; // Account for title (16px + 5px), instruction (11px + 5px), padding (10px*2)

            // Set SVG dimensions
            mapSvg.attr("width", mapWidth)
                .attr("height", mapHeight)
                .attr("viewBox", `0 0 ${mapWidth} ${mapHeight}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            // Clear any existing content
            mapSvg.selectAll("*").remove();

            // Set up projection
            const projection = d3.geoMercator()
                .fitSize([mapWidth, mapHeight], boundaryData);

            const path = d3.geoPath().projection(projection);

            // Create map group
            const g = mapSvg.append("g");

            // Draw Singapore boundary
            g.selectAll("path.boundary")
                .data(boundaryData.features)
                .enter()
                .append("path")
                .attr("class", "boundary")
                .attr("d", path)
                .attr("fill", "#ffe680")
                .attr("stroke", "#999")
                .attr("stroke-width", 1)
                .attr("opacity", 0.7);

            // Draw parks
            const parkGroup = g.append("g").attr("class", "parks-layer");
            parkGroup.selectAll("circle.park")
                .data(parksData.features)
                .enter()
                .append("circle")
                .attr("class", "park")
                .attr("cx", d => projection(d.geometry.coordinates)[0])
                .attr("cy", d => projection(d.geometry.coordinates)[1])
                .attr("r", 3)
                .attr("fill", "#c0392b")
                .attr("stroke", "#922b21")
                .attr("stroke-width", 1)
                .attr("opacity", 0.8)
                .style("cursor", "pointer")
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("r", 5)
                        .attr("opacity", 1);

                    const parkName = d.properties.NAME || "Unknown Park";
                    tooltip.style("display", "block")
                        .html(`<strong>üèûÔ∏è ${parkName}</strong>`);
                })
                .on("mousemove", function (event) {
                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function () {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("r", 3)
                        .attr("opacity", 0.8);

                    tooltip.style("display", "none");
                });

            // Create group for user interactions
            const interactionGroup = g.append("g").attr("class", "interaction-layer");

            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([1, 8])
                .on("zoom", function (event) {
                    g.attr("transform", event.transform);
                });

            mapSvg.call(zoom);

            // Set cursor style
            mapSvg.style("cursor", "crosshair");

            // Add click handler (override zoom's click to allow our custom click)
            mapSvg.on("click.custom", function (event) {
                // Get the pointer position relative to the transformed group
                const [mouseX, mouseY] = d3.pointer(event, g.node());
                const clickedCoords = projection.invert([mouseX, mouseY]);

                // Find nearest park
                let nearestPark = null;
                let minDistance = Infinity;

                parksData.features.forEach(park => {
                    const parkCoords = park.geometry.coordinates;

                    // Calculate Haversine distance
                    const R = 6371000; // Earth's radius in meters
                    const dLat = (parkCoords[1] - clickedCoords[1]) * Math.PI / 180;
                    const dLon = (parkCoords[0] - clickedCoords[0]) * Math.PI / 180;
                    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(clickedCoords[1] * Math.PI / 180) * Math.cos(parkCoords[1] * Math.PI / 180) *
                        Math.sin(dLon / 2) * Math.sin(dLon / 2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    const distance = R * c;

                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestPark = park;
                    }
                });

                // Clear previous markers and lines
                interactionGroup.selectAll("*").remove();

                if (nearestPark) {
                    const parkCoords = projection(nearestPark.geometry.coordinates);
                    const clickCoords = projection(clickedCoords);

                    // Draw line from clicked point to nearest park
                    interactionGroup.append("line")
                        .attr("x1", clickCoords[0])
                        .attr("y1", clickCoords[1])
                        .attr("x2", parkCoords[0])
                        .attr("y2", parkCoords[1])
                        .attr("stroke", "#e74c3c")
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "5,5")
                        .attr("opacity", 0.8);

                    // Draw marker for clicked point
                    interactionGroup.append("circle")
                        .attr("cx", clickCoords[0])
                        .attr("cy", clickCoords[1])
                        .attr("r", 5)
                        .attr("fill", "#3498db")
                        .attr("stroke", "#2980b9")
                        .attr("stroke-width", 2);

                    // Highlight nearest park
                    interactionGroup.append("circle")
                        .attr("cx", parkCoords[0])
                        .attr("cy", parkCoords[1])
                        .attr("r", 6)
                        .attr("fill", "none")
                        .attr("stroke", "#e74c3c")
                        .attr("stroke-width", 3);

                    // Get park name
                    const parkName = nearestPark.properties.NAME || "Unknown Park";

                    // Update distance info
                    const distanceContent = document.getElementById("distance-content");
                    distanceContent.innerHTML = `Your Location to ${parkName} is ${(minDistance / 1000).toFixed(2)}km`;
                }
            });
        }

        // Create tooltip
        const tooltip = d3.select("body")
            .append("div")
            .style("position", "absolute")
            .style("display", "none")
            .style("background", "rgba(0, 0, 0, 0.8)")
            .style("color", "white")
            .style("padding", "8px")
            .style("border-radius", "4px")
            .style("font-size", "12px")
            .style("pointer-events", "none")
            .style("z-index", "1000");
    </script>
</body>

</html>
